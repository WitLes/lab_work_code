##L.X.


之前我考虑时效网络上的传播是最简单SI模型，即不考虑个体恢复。下一步你想一想怎样拓展到SIS或者SIR模型。这样今后你就可以在这些模型上开展工作了。

现阶段你可以先在原有SIS模型的算法思路的基础上，在三元组（或者四元组，即额外考虑时效边的持续时间）表示的时效网络上实现SIS和SIR模型。分别考虑固定传播率、恢复率（即经典SIS和SIR模型），以及非固定传播率、恢复率（即任意等待时间分布、恢复时间分布，非马尔科夫传播模型）两种情况。刚才给你的文献中的Gillespie算法是一个锦上添花的要求，如果你今后要处理大规模实际网络的时候应该会快很多，实现应该不难但可能理解起来现在有一定困难，你可以先看一下。



##疑问
#关于之前说到的在传播中的SI模型

首先，你说之前考虑时效网络上的传播只是简单的SI模型，不考虑个体的恢复。

但根据我的理解，在我所实现的扩散路径中，是不存在 Suspected->Infected 这个步骤的，只要是交互节点中有一个被感染，另外一个就一定会被感染。也就是说，如果我现在要实现时效网络中的SI模型，和之前的单源时效传播路径的算法(之前动画实现的算法)是不一样的。


差别在传播时节点的感染能力上，之前我的传播路径算法默认接触即感染(信息的扩散)，SI\SIR\SIS模型要求接触后以概率传染。

也就是我要在传播上设定新的**传播概率** OR **等待时间**？

如果要说成是SI模型，我的理解是，等待时间就是是感染的等待时间，那么每一个节点不管等待时间多长，最后都是会被感染的，也就是只要与病毒接触，在一段时间后都会感染，和经典SI模型中的感染率不太一样。

###对于问题，我的想法是：

如果是以固定传播率、恢复率来传播：

	（用一个dict记录下当前时间的Infected节点）
	依次输入每一个三元组（按时间顺序）:
	{
		步骤1.判断该三元组会不会引起病毒的扩散：
			A.如果该三元组中有一个节点被感染，那另一个节点就以p的概率被感染。
			B.如果两个节点都infected，continue
			C.如果两个节点都没有infected，continue
		步骤2.dict中的元素以一定的概率恢复，恢复成功则从dict中移除

如果是以等待时间、恢复时间来传播：

	（用一个dict记录下当前时间的Infected节点）
	依次输入每一个四元组（按时间顺序）:
	{
		步骤1.按分布生成等待时间Tuv，并判断：
			A.如果该三元组中有一个节点被感染，那另一个节点就在等待时间Tuv之后被感染（如果还在接触）。
			B.如果两个节点都infected，continue
			C.如果两个节点都没有infected，continue
		步骤2.对于刚进入dict中的元素，按恢复分布生成恢复时间Tr
			将恢复时间已到的节点移除dict
	}


#Q1:
如果是这样，会不会影响到论文之后的步骤？因为论文里是基于扩散到达时间和等待时间的**扩散**，和SIR、SIS中的**感染**有所不同，感染是以概率的，而等待时间是一个随机变量。

还是说以一个等待时间的随机变量来衡量接触感染时间？但这样的话就需要用四元组形式，判断等待时间是否大于接触时间，确定是否感染。

#Q2:
还是一开始提到的问题，按Diffusion的思路，只有相互接触的节点才会传播病毒，也就是从病毒源开始的扩散路径，那么这个接触传播是认为：

1. 一定会传播
2. 以一个概率传播（SIR\SIS\SI）
3. 用等待时间分布，恢复时间分布传播

如果是3，这个等待时间分布意味着传播的延时吗？如果等待时间>接触时间，不扩散，如果等待时间<接触时间，扩散。

2，3两种方式相比，3的优点表现在哪？

#Q3:

在Q2中的2，3的情况下，如果是从单源开始的扩散，我觉得可以扩散的几率很小，因为如果源节点无法感染其他节点，那病毒就不会传播了。

#Q4:
我觉得单源节点的信息扩散和单源节点的病毒传播(SI\SIR\SIS)，这两种思想是不太一样的，不知道该怎么衡量？

#Q5:
同一时刻能否传染多个节点？


##回复
你说的是正确的，之前更确切的说是相当于传播率为1时的一个特例。你后面提到的两种思路也是正确的，可以照此实现。下面的几个问题是这样的：

Q1：确实原文和SIR和SIS扩散都不同，但可以看做是传播率为1、恢复率为0（或者恢复时间infty）的特例，实现SIR和SIS既能SI扩散过程，也便于你今后对算法进行扩展。


Q2：你的理解是正确的。关于方式3的优点，它对应了最一般的扩散过程，方式2是方式3的一个特例，当传播率固定时，对应的等待时间分布就服从指数分布（参见大论文1.2.2节），同理考虑任意恢复时间分布是将固定恢复率推广到可变回复率的一般情况。

Q3：这个问题很好。首先我们还是限定在单一传播源的情况，但确实可能全体个体均恢复了，扩散不再继续，这样算法终止就可以了，未感染的节点的首达时间输出为infty就可以了。另外传播过程终止是由于如果时间窗口太短造成的，可以用所谓的“时间窗口的周期边界条件”，简单的说，假如现有观测到的三元组的交互时间都属于区间[0,T]，则每一个三元组(u,v,t)延拓为一系列时效边(u,v,t+kT), k=0,1,2... 这样可以确保传播过程持续下去。

Q4：病毒传播除了首达时间，还需要记录恢复时间，才是完整的传播过程数据。可以用之前的动画演示程序来检验程序输出的正确性。

Q5：这个问题确实需要区分这两种情况，同一时刻信息能否同时传播到多个节点会直接影响传播路径（参见大论文对图1.6的解释）。简单起见现在可以只考虑前一种简单的情况。但即便是在这种情况下，不允许时效路径在同一时刻经过多个节点，仍然有可能存在多条并存的最短路径，其实需要把所有的路径都保留和输出出来，你可以想想应该怎么处理。

#解决方法
##同一时刻的传播问题

对于一个时刻的所有连边，将其全部放入一个字典中，每一个时间点上进行扩散的判断，如果在字典中存在相应的感染节点，而其连边的节点未被感染，则判断是否被感染，对于字典的操作仅仅进行此步骤，防止病毒在一个时间点进行了多次的扩散。

**注意这个字典是每一时刻出现的节点，而储存被感染的节点的信息则是另一个字典，这个字典中保存的是被感染节点的编号和感染时间**
所以在算法中，存在两个临时字典：

1. 感染节点的字典。{编号：感染时间，父节点}
2. 每一时刻（或时间窗）的节点对，也就是{节点1：节点2}，这样不仅可以处理无向图（遍历key和value，也可以处理有向图，连边是key->value）

```
大循环（三元组是否遍历完）{
	找到目前时间点的所有三元组，存入节点对字典tuple_dict;
	判断tuple_dict中所有的连边是否存在S->I的情况，如果存在，进行概率感染操作；
}
```
如果想同时处理多个连边的感染情况，但每个时间点都只能感染一次，可以对每一个节点对进行是否进行过感染操作的标记。因为感染操作只在I->S的连边上进行，判断该时刻的感染结束的条件是所有的节点对都进行了感染操作。**并且要注意每一次感染操作之后，都要重新遍历当前时刻的节点对字典，因为一次更新可能会将节点对中的部分节点感染，就会出现S->S的连边变成I->S的连边。**

**重要**

##多条等长的最短路径的输出问题