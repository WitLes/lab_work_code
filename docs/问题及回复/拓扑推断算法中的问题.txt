在算法4拓扑重构的过程中，有几个疑问

A.WTD的离散化具体是怎么实现的？
我的想法是，对于仿真数据，在算法的迭代之前，我们都是假设用指数分布作为迭代的初始WTD分布，那么离散化指的就应该是对指数分布的离散化
	2.首先根据我们利用之前使用假设的均质高斯分布（这也是我们想要得到的迭代结果）生成的首达时间的集合DATs，找到生成的数据中的等待时间上界l_t
	3.在[1,l_t]这个支撑集之内，对我们算法默认的初始WTD(指数函数)进行离散化：
		3.1选取一个间隔delta，将该区间分成若干等分；
		3.2计算每一个小区间内的函数积分(使用其他的工具包)，离散化的数据点的值用(积分值/delta)代替；
		3.3得到在支撑集内的离散化等待时间分布，用一个数组表示。数组长度是离散化的数据点的总数，对应的值是每一个小区间内的平均概率密度(也就是说这个值乘以小区间长度delta等于这个区间内的概率质量)
		3.4重新将这些离散数据的和进行归一化。（因为分布函数在实轴上的积分是1，离散化后的概率质量之和因为支撑集的限制，肯定是小于1的，要先进行归一）
	4.利用离散化的初始指数WTD，就可以带入算法进行迭代了.
	
Q1：不知道到这个方法合不合适？因为我害怕对一个小区间delta内的函数积分会过小，导致精度不够。实际该如何取值小区间长度delta？
Q2：换个思路，也就是怎么平衡支撑集长度和小区间delta长度的关系？或者是固定地保证离散化的WTD的数据点的数量是一个定值？还是保证小区间的长度是一个定值？

B.在算法中，对边(u,v)的迭代中，有这个一个大循环：
foreach (u,v) do:.....也就是考虑增删任意边。

Q1：问题是：对于一个进入算法刚刚初始化的图来说，图是空图，也就是说，图中不存在任何连边(u,v)，那么这个循环的意思是，每一次都遍历从DAT导出的所有可能的(u,v)连边吗？（只要t_u < t_v,就要对这个可能存在的连边(u,v)进行判断）
Q2：换种思路，是不是需要在迭代之间，先利用所有的首达时间数据，计算出所有可能的连边对{(u,v)},t_u<t_v,那么每一次循环的条件就是，遍历所有可能的连边对(u,v)了?

